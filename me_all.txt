Design menu driven application demonstrating use of different system calls.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <string.h>

// Process-related system calls submenu
void processRelatedCalls() {
    int choice;
    pid_t pid;
    printf("\n-- Process Related System Calls --\n");
    printf("1. fork()\n");
    printf("2. exit()\n");
    printf("3. wait()\n");
    printf("Enter choice: ");
    scanf("%d", &choice);

    switch (choice) {
        case 1:
            pid = fork();
            if (pid == 0) {
                printf("Child process (PID: %d)\n", getpid());
                exit(0);
            } else if (pid > 0) {
                printf("Parent process (PID: %d)\n", getpid());
            } else {
                perror("fork failed");
            }
            break;
        case 3:
            pid = fork();
            if (pid == 0) {
                printf("Child process (PID: %d) exiting...\n", getpid());
                exit(0);
            } else if (pid > 0) {
                wait(NULL);
                printf("Parent process waited for child (PID: %d)\n", pid);
            } else {
                perror("fork failed");
            }
            break;
        default:
            printf("Invalid choice.\n");
    }
}

// File-related system calls submenu
void fileRelatedCalls() {
    int choice;
    char filename[100], data[100];
    printf("\n-- File Related System Calls --\n");
    printf("1. open(), read(), write(), close()\n");
    printf("2. link(), unlink()\n");
    printf("3. stat()\n");
    printf("Enter choice: ");
    scanf("%d", &choice);

    switch (choice) {
        case 1: {
            printf("Enter filename: ");
            scanf("%s", filename);
            int fd = open(filename, O_CREAT | O_RDWR, 0666);
            if (fd == -1) {
                perror("Failed to open file");
                return;
            }
            printf("Enter data to write: ");
            scanf(" %[^\n]s", data);
            write(fd, data, strlen(data));
            lseek(fd, 0, SEEK_SET); // Reset file pointer for reading
            read(fd, data, sizeof(data));
            printf("Data read from file: %s\n", data);
            close(fd);
            break;
        }
        case 2:
            printf("Enter filename for linking: ");
            scanf("%s", filename);
            if (link(filename, "hardlink") == 0) {
                printf("Hard link created.\n");
                unlink("hardlink");
                printf("Hard link removed.\n");
            } else {
                perror("Linking failed");
            }
            break;
        case 3:
            printf("Enter filename for stat: ");
            scanf("%s", filename);
            struct stat fileStat;
            if (stat(filename, &fileStat) == 0) {
                printf("File Size: %ld bytes\n", fileStat.st_size);
                printf("Number of Links: %ld\n", fileStat.st_nlink);
                printf("File inode: %ld\n", fileStat.st_ino);
            } else {
                perror("stat failed");
            }
            break;
        default:
            printf("Invalid choice.\n");
    }
}

// Communication-related system calls submenu
void communicationRelatedCalls() {
    int choice;
    printf("\n-- Communication Related System Calls --\n");
    printf("1. pipe()\n");
    printf("2. FIFO (mkfifo())\n");
    printf("Enter choice: ");
    scanf("%d", &choice);

    switch (choice) {
        case 1: {
            int pipefd[2];
            char buf;
            if (pipe(pipefd) == -1) {
                perror("pipe failed");
                return;
            }
            pid_t pid = fork();
            if (pid == 0) {
                close(pipefd[0]);
                write(pipefd[1], "Hello, Parent!", 15);
                close(pipefd[1]);
                exit(0);
            } else if (pid > 0) {
                close(pipefd[1]);
                read(pipefd[0], &buf, sizeof(buf));
                printf("Parent read from pipe: %s\n", &buf);
                close(pipefd[0]);
                wait(NULL);
            } else {
                perror("fork failed");
            }
            break;
        }
        case 2:
            // Implement mkfifo example if needed
            printf("FIFO example not implemented.\n");
            break;
        default:
            printf("Invalid choice.\n");
    }
}

// Information-related system calls submenu
void informationRelatedCalls() {
    printf("\n-- Information Related System Calls --\n");
    printf("Process ID: %d\n", getpid());
    printf("Parent Process ID: %d\n", getppid());
    printf("User ID: %d\n", getuid());
    printf("Group ID: %d\n", getgid());
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("Current Working Directory: %s\n", cwd);
    } else {
        perror("getcwd failed");
    }
}

int main() {
    int choice;

    while (1) {
        printf("\n-- Menu --\n");
        printf("1. Process Related System Calls\n");
        printf("2. File Related System Calls\n");
        printf("3. Communication Related System Calls\n");
        printf("4. Information Related System Calls\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                processRelatedCalls();
                break;
            case 2:
                fileRelatedCalls();
                break;
            case 3:
                communicationRelatedCalls();
                break;
            case 4:
                informationRelatedCalls();
                break;
            case 5:
                printf("Exiting program...\n");
                exit(0);
            default:
                printf("Invalid choice. Please enter a number between 1 and 5.\n");
        }
    }

    return 0;
}


Implement multithreading for Matrix Operations using Pthreads.


#include <stdio.h>
#include <stdlib.h>

#define SIZE 3

void print_matrix(int matrix[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int A[SIZE][SIZE], B[SIZE][SIZE], sum[SIZE][SIZE], product[SIZE][SIZE];

    // Initialize matrices A and B
    printf("Enter elements of matrix A (%d x %d):\n", SIZE, SIZE);
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            scanf("%d", &A[i][j]);
        }
    }

    printf("Enter elements of matrix B (%d x %d):\n", SIZE, SIZE);
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            scanf("%d", &B[i][j]);
        }
    }

    // Matrix Addition
    printf("\nMatrix Addition:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            sum[i][j] = A[i][j] + B[i][j];
        }
    }
    // Print the result of addition
    print_matrix(sum);

    // Matrix Multiplication
    printf("\nMatrix Multiplication:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            product[i][j] = 0;
            for (int k = 0; k < SIZE; k++) {
                product[i][j] += A[i][k] * B[k][j];
            }
        }
    }

    // Print the result of multiplication
    print_matrix(product);

    return 0;
}

Reader-Writer Problem Using Threads and Mutex

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX_READERS 5
#define MAX_WRITERS 2

int data = 80; // Shared data
int read_count = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t write_mutex = PTHREAD_MUTEX_INITIALIZER;

void* reader(void* arg) {
    int reader_id = *(int*)arg;

    printf("Reader %d is trying to access critical region\n", reader_id);
    pthread_mutex_lock(&mutex);
    read_count++;
    if (read_count == 1) {
        pthread_mutex_lock(&write_mutex);
    }
    pthread_mutex_unlock(&mutex);

    printf("Reader %d has got access to critical section\n", reader_id);
    printf("Reader %d read data: %d\n", reader_id, data);

    pthread_mutex_lock(&mutex);
    read_count--;
    if (read_count == 0) {
        pthread_mutex_unlock(&write_mutex);
    }
    pthread_mutex_unlock(&mutex);

    printf("Reader %d has left the critical section\n", reader_id);
    return NULL;
}

void* writer(void* arg) {
    int writer_id = *(int*)arg;

    printf("Writer %d is trying to access critical region\n", writer_id);
    pthread_mutex_lock(&write_mutex);

    printf("Writer %d has got access to critical region\n", writer_id);
    data = rand() % 100; // Simulate writing new data
    printf("Writer %d wrote data: %d\n", writer_id, data);

    pthread_mutex_unlock(&write_mutex);
    printf("Writer %d has left the critical section\n", writer_id);
    return NULL;
}

int main() {
    pthread_t readers[MAX_READERS], writers[MAX_WRITERS];
    int reader_ids[MAX_READERS], writer_ids[MAX_WRITERS];

    for (int i = 0; i < MAX_READERS; i++) {
        reader_ids[i] = i;
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }

    for (int i = 0; i < MAX_WRITERS; i++) {
        writer_ids[i] = i;
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    for (int i = 0; i < MAX_READERS; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < MAX_WRITERS; i++) {
        pthread_join(writers[i], NULL);
    }

    return 0;
}

input = ./reader_writer


Reader-Writer Problem Using Threads and Semaphores

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define MAX_READERS 5
#define MAX_WRITERS 2

int data = 80; // Shared data
sem_t read_mutex;
sem_t write_mutex;
int read_count = 0;

void* reader(void* arg) {
    int reader_id = *(int*)arg;

    printf("Reader %d is trying to access critical region\n", reader_id);
    sem_wait(&read_mutex); // Lock for reading
    read_count++;
    if (read_count == 1) {
        sem_wait(&write_mutex); // First reader locks the writer
    }
    sem_post(&read_mutex); // Unlock the read_mutex

    printf("Reader %d has got access to critical section\n", reader_id);
    printf("Read Data: %d from Reader Number: %d\n", data, reader_id);

    sem_wait(&read_mutex); // Lock for reading
    read_count--;
    if (read_count == 0) {
        sem_post(&write_mutex); // Last reader unlocks the writer
    }
    sem_post(&read_mutex); // Unlock the read_mutex

    printf("Reader %d has left the critical section\n", reader_id);
    return NULL;
}

void* writer(void* arg) {
    int writer_id = *(int*)arg;

    printf("Writer %d is trying to access critical region\n", writer_id);
    sem_wait(&write_mutex); // Lock for writing

    printf("Writer %d has got access to critical section\n", writer_id);
    data = rand() % 100; // Simulate writing new data
    printf("Writer has wrote. Data Now: %d\n", data);

    sem_post(&write_mutex); // Unlock the write_mutex
    printf("Writer %d has left the critical section\n", writer_id);
    return NULL;
}

int main() {
    pthread_t readers[MAX_READERS], writers[MAX_WRITERS];
    int reader_ids[MAX_READERS], writer_ids[MAX_WRITERS];

    // Initialize semaphores
    sem_init(&read_mutex, 0, 1);
    sem_init(&write_mutex, 0, 1);

    for (int i = 0; i < MAX_READERS; i++) {
        reader_ids[i] = i;
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }

    for (int i = 0; i < MAX_WRITERS; i++) {
        writer_ids[i] = i;
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    for (int i = 0; i < MAX_READERS; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < MAX_WRITERS; i++) {
        pthread_join(writers[i], NULL);
    }

    // Destroy semaphores
    sem_destroy(&read_mutex);
    sem_destroy(&write_mutex);

    return 0;
}

input = ./reader_writer




Producer-Consumer Using Semaphores

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE] = {0};
int count = 0;

sem_t empty;
sem_t full;
pthread_mutex_t mutex;

// Function for producer
void* producer(void* arg) {
    while (1) {
        int item = rand() % 100;
        sem_wait(&empty);
        pthread_mutex_lock(&mutex);

        printf("Producer has got access to critical section\n");
        // Add the item to the buffer
        buffer[count] = item;
        printf("Element %d has been added to buffer\n", item);
        printf("Buffer after adding element: [");
        for (int i = 0; i < BUFFER_SIZE; i++) {
            printf("%d ", buffer[i]);
        }
        printf("]\n");

        count++;
        pthread_mutex_unlock(&mutex);
        printf("Producer has left the critical section\n");

        sem_post(&full);

        sleep(1);
    }
}

// Function for consumer
void* consumer(void* arg) {
    while (1) {
        sem_wait(&full);
        pthread_mutex_lock(&mutex);

        printf("Consumer has got access to critical section\n");
        // Remove the item from the buffer
        int item = buffer[0];
        for (int i = 0; i < BUFFER_SIZE - 1; i++) {
            buffer[i] = buffer[i + 1];
        }
        buffer[BUFFER_SIZE - 1] = 0;
        count--;

        printf("Buffer after removing element: [");
        for (int i = 0; i < BUFFER_SIZE; i++) {
            printf("%d ", buffer[i]);
        }
        printf("] (Buffer is empty)\n");
        printf("Element %d has been consumed\n", item);

        pthread_mutex_unlock(&mutex);
        printf("Consumer has left the critical section\n");

        sem_post(&empty);

        sleep(1);
    }
}

int main() {
    pthread_t prod, cons;

    // Initialize the semaphores
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);

    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);

    // Create producer and consumer threads
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    // Wait for threads to finish (in this case they won't)
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    // Destroy semaphores and mutex
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}


Producer-Consumer Using Mutexes
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE 1

int buffer[BUFFER_SIZE];
int count = 0;
pthread_mutex_t mutex;

// Function for producer
void* producer(void* arg) {
    while (1) {
        int item = rand() % 100;

        printf("Producer is trying to access critical section\n");
        pthread_mutex_lock(&mutex);
        printf("Producer has got access to critical section\n");

        // Add the item to the buffer
        buffer[count] = item;
        count++;

        printf("Element %d has been added to buffer\n", item);
        printf("Buffer after adding element: [");
        for (int i = 0; i < count; i++) {
            printf("%d ", buffer[i]);
        }
        printf("]\n");

        pthread_mutex_unlock(&mutex);  // Release mutex
        printf("Producer has left the critical section\n");

        sleep(1);
    }
}

// Function for consumer
void* consumer(void* arg) {
    while (1) {
        printf("Consumer is trying to access critical section\n");
        pthread_mutex_lock(&mutex);

        // Check if the buffer is empty
        if (count == 0) {
            printf("Consumer waiting, buffer is empty\n");
            pthread_mutex_unlock(&mutex);
            sleep(1);
            continue;
        }

        printf("Consumer has got access to critical section\n");

        // Remove the item from the buffer
        int item = buffer[0];
        count--;
        for (int i = 0; i < count; i++) {
            buffer[i] = buffer[i + 1];
        }

        printf("Buffer after removing element: [");
        for (int i = 0; i < count; i++) {
            printf("%d ", buffer[i]);
        }
        printf("] (Buffer is empty)\n");

        pthread_mutex_unlock(&mutex);
        printf("Consumer has left the critical section\n");
        printf("Element %d has been consumed\n", item);

        sleep(1);
    }
}

int main() {
    pthread_t prod, cons;  // Threads for producer and consumer

    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);

    // Create producer and consumer threads
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    // Wait for threads to finish (in this case they won't)
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    // Destroy the mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}



Dining Philosophers Problem Using Threads and Semaphores

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5

// Declare the semaphores for each fork
sem_t forks[NUM_PHILOSOPHERS];

// Declare mutex for printing to prevent simultaneous printing from multiple threads
pthread_mutex_t print_mutex;

// Function to simulate a philosopher's thinking and eating
void* philosopher(void* num) {
    int id = *(int*)num;

    while (1) {
        // Think
        pthread_mutex_lock(&print_mutex);
        printf("Philosopher %d is thinking\n", id);
        pthread_mutex_unlock(&print_mutex);

        sleep(rand() % 3 + 1);  // Thinking for a random time

        // Try to pick up the left fork
        sem_wait(&forks[id]);

        // Try to pick up the right fork
        sem_wait(&forks[(id + 1) % NUM_PHILOSOPHERS]);

        // Eating
        pthread_mutex_lock(&print_mutex);
        printf("Philosopher %d is eating\n", id);
        pthread_mutex_unlock(&print_mutex);

        sleep(rand() % 3 + 1);  // Eating for a random time

        // Put down the right fork
        sem_post(&forks[(id + 1) % NUM_PHILOSOPHERS]);

        // Put down the left fork
        sem_post(&forks[id]);
    }

    return NULL;
}

int main() {
    pthread_t threads[NUM_PHILOSOPHERS];
    int philosopher_ids[NUM_PHILOSOPHERS];

    // Initialize semaphores for each fork (each fork is initially available)
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_init(&forks[i], 0, 1);  // Each fork is initially available (binary semaphore)
    }

    // Initialize the mutex for printing to avoid mixed output
    pthread_mutex_init(&print_mutex, NULL);

    // Create philosopher threads
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        philosopher_ids[i] = i;
        pthread_create(&threads[i], NULL, philosopher, (void*)&philosopher_ids[i]);
    }

    // Wait for threads to finish (they will run indefinitely in this case)
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy semaphores and mutex
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_destroy(&forks[i]);
    }
    pthread_mutex_destroy(&print_mutex);

    return 0;
}

gcc -o dining_philosophers dining_philosophers.c -lpthread

./dining_philosophers



9 First Come First Serve (FCFS) Scheduling

#include <stdio.h>

void findWaitingTime(int processes[], int n, int bt[], int wt[]) {
    wt[0] = 0;
    for (int i = 1; i < n; i++) {
        wt[i] = bt[i - 1] + wt[i - 1];
    }
}

void findTurnaroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {
    for (int i = 0; i < n; i++) {
        tat[i] = bt[i] + wt[i];
    }
}

void findFinishTime(int processes[], int n, int bt[], int wt[], int ft[]) {
    for (int i = 0; i < n; i++) {
        ft[i] = wt[i] + bt[i];
    }
}

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int processes[n], bt[n], wt[n], tat[n], ft[n];

    printf("Enter burst time for each process: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
        processes[i] = i + 1;
    }

    findWaitingTime(processes, n, bt, wt);
    findTurnaroundTime(processes, n, bt, wt, tat);
    findFinishTime(processes, n, bt, wt, ft);

    printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time\tFinish Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t\t\t%d\n", processes[i], bt[i], wt[i], tat[i], ft[i]);
    }

    return 0;
}

inputs = 3 
687 

10 Shortest Job First (Preemptive and Non-Preemptive)

Non-Preemptive SJF

#include <stdio.h>

void findWaitingTime(int processes[], int n, int bt[], int wt[]) {
    int remainingTime[n];
    for (int i = 0; i < n; i++) {
        remainingTime[i] = bt[i];
    }

    wt[0] = 0;
    for (int i = 1; i < n; i++) {
        int min = remainingTime[0], index = 0;
        for (int j = 1; j < n; j++) {
            if (remainingTime[j] < min && remainingTime[j] > 0) {
                min = remainingTime[j];
                index = j;
            }
        }
        remainingTime[index] = -1;
        wt[i] = bt[i - 1] + wt[i - 1];
    }
}

void findTurnaroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {
    for (int i = 0; i < n; i++) {
        tat[i] = bt[i] + wt[i];
    }
}

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int processes[n], bt[n], wt[n], tat[n];

    printf("Enter burst time for each process: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
        processes[i] = i + 1;
    }

    findWaitingTime(processes, n, bt, wt);
    findTurnaroundTime(processes, n, bt, wt, tat);

    printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\n", processes[i], bt[i], wt[i], tat[i]);
    }

    return 0;
}

Preemptive SJF (Shortest Job First with Preemption)

#include <stdio.h>

void findWaitingTime(int processes[], int n, int bt[], int wt[]) {
    int remainingTime[n];
    for (int i = 0; i < n; i++) {
        remainingTime[i] = bt[i];
    }

    int completed = 0, t = 0, shortest = 0, minTime = 9999;
    while (completed < n) {
        for (int i = 0; i < n; i++) {
            if (remainingTime[i] < minTime && remainingTime[i] > 0) {
                shortest = i;
                minTime = remainingTime[i];
            }
        }

        remainingTime[shortest]--;
        if (remainingTime[shortest] == 0) {
            completed++;
            minTime = 9999;
        }

        t++;
    }
}

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int processes[n], bt[n], wt[n];

    printf("Enter burst time for each process: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
        processes[i] = i + 1;
    }

    findWaitingTime(processes, n, bt, wt);

    printf("\nProcess\tBurst Time\tWaiting Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\n", processes[i], bt[i], wt[i]);
    }

    return 0;
}


11 . Priority Scheduling (Preemptive and Non-Preemptive)

Non-Preemptive Priority Scheduling

#include <stdio.h>

void findWaitingTime(int processes[], int n, int bt[], int priority[], int wt[]) {
    int completed[n];
    for (int i = 0; i < n; i++) {
        completed[i] = 0;
    }

    int t = 0, completedProcesses = 0;
    while (completedProcesses < n) {
        int min = 9999, index = -1;
        for (int i = 0; i < n; i++) {
            if (!completed[i] && priority[i] < min) {
                min = priority[i];
                index = i;
            }
        }

        wt[index] = t;
        t += bt[index];
        completed[index] = 1;
        completedProcesses++;
    }
}

void findTurnaroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {
    for (int i = 0; i < n; i++) {
        tat[i] = bt[i] + wt[i];
    }
}

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int processes[n], bt[n], wt[n], tat[n], priority[n];

    printf("Enter burst time and priority for each process: ");
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &bt[i], &priority[i]);
        processes[i] = i + 1;
    }

    findWaitingTime(processes, n, bt, priority, wt);
    findTurnaroundTime(processes, n, bt, wt, tat);

    printf("\nProcess\tBurst Time\tPriority\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t\t%d\n", processes[i], bt[i], priority[i], wt[i], tat[i]);
    }

    return 0;
}


Preemptive Priority Scheduling


#include <stdio.h>

struct process {
    int id;
    int bt;  // Burst Time
    int at;  // Arrival Time
    int pr;  // Priority
    int wt;  // Waiting Time
    int tat; // Turnaround Time
    int ft;  // Finish Time
};

void findWaitingTime(struct process proc[], int n) {
    int rt[n]; // Remaining Time
    for (int i = 0; i < n; i++) {
        rt[i] = proc[i].bt;
    }

    int time = 0;
    int completed = 0;

    while (completed < n) {
        int idx = -1;
        int minPriority = 99999;
        for (int i = 0; i < n; i++) {
            if (proc[i].at <= time && rt[i] > 0 && proc[i].pr < minPriority) {
                minPriority = proc[i].pr;
                idx = i;
            }
        }

        if (idx == -1) {
            time++;
            continue;
        }

        rt[idx]--;
        if (rt[idx] == 0) {
            proc[idx].ft = time + 1;
            proc[idx].tat = proc[idx].ft - proc[idx].at;
            proc[idx].wt = proc[idx].tat - proc[idx].bt;
            completed++;
        }
        time++;
    }
}

void findTurnaroundTime(struct process proc[], int n) {
    for (int i = 0; i < n; i++) {
        proc[i].tat = proc[i].ft - proc[i].at;
    }
}

void findWaitingTime(struct process proc[], int n) {
    for (int i = 0; i < n; i++) {
        proc[i].wt = proc[i].tat - proc[i].bt;
    }
}

void printResults(struct process proc[], int n) {
    printf("Process ID\tArrival Time\tBurst Time\tPriority\tFinish Time\tTurnaround Time\tWaiting Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n",
            proc[i].id, proc[i].at, proc[i].bt, proc[i].pr, proc[i].ft, proc[i].tat, proc[i].wt);
    }
}

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    struct process proc[n];

    printf("Enter Arrival Time, Burst Time and Priority for each process:\n");
    for (int i = 0; i < n; i++) {
        proc[i].id = i + 1;
        printf("Process %d\n", i + 1);
        printf("Arrival Time: ");
        scanf("%d", &proc[i].at);
        printf("Burst Time: ");
        scanf("%d", &proc[i].bt);
        printf("Priority: ");
        scanf("%d", &proc[i].pr);
    }

    findWaitingTime(proc, n);
    findTurnaroundTime(proc, n);
    findWaitingTime(proc, n);

    printResults(proc, n);

    return 0;
}


input Enter number of processes: 3
Enter Arrival Time, Burst Time, and Priority for each process:
Process 1
Arrival Time: 0
Burst Time: 4
Priority: 2
Process 2
Arrival Time: 1
Burst Time: 3
Priority: 1
Process 3
Arrival Time: 2
Burst Time: 2
Priority: 3


Round Robin Scheduling

#include <stdio.h>

void findWaitingTime(int n, int bt[], int wt[], int quantum) {
    int remaining_bt[n];
    for (int i = 0; i < n; i++) {
        remaining_bt[i] = bt[i];
    }

    int t = 0; // current time
    while (1) {
        int done = 1;
        for (int i = 0; i < n; i++) {
            if (remaining_bt[i] > 0) {
                done = 0;
                if (remaining_bt[i] > quantum) {
                    t += quantum;
                    remaining_bt[i] -= quantum;
                } else {
                    t += remaining_bt[i];
                    wt[i] = t - bt[i];
                    remaining_bt[i] = 0;
                }
            }
        }
        if (done == 1) break;
    }
}

void findTurnaroundTime(int n, int bt[], int wt[], int tat[]) {
    for (int i = 0; i < n; i++) {
        tat[i] = bt[i] + wt[i];
    }
}

int main() {
    int n, quantum;
    printf("Enter number of processes: ");
    scanf("%d", &n);
    int bt[n], wt[n], tat[n];

    printf("Enter burst time for each process:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
    }

    printf("Enter time quantum: ");
    scanf("%d", &quantum);

    findWaitingTime(n, bt, wt, quantum);
    findTurnaroundTime(n, bt, wt, tat);

    printf("Process\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\n", i + 1, bt[i], wt[i], tat[i]);
    }

    return 0;
}

input Enter number of processes: 3
Enter burst time for each process:
5
7
3
Enter time quantum: 4


Banker's Algorithm for Deadlock Avoidance

#include <stdio.h>

int main() {
    int i, j, n, m;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resources: ");
    scanf("%d", &m);

    int alloc[n][m], max[n][m], need[n][m], avail[m];
    int finish[n], safeSeq[n], count = 0;

    printf("Enter allocation matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("Enter max matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("Enter available resources:\n");
    for(i = 0; i < m; i++)
        scanf("%d", &avail[i]);

    for(i = 0; i < n; i++) {
        finish[i] = 0;
        for(j = 0; j < m; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
        }
    }

    // Check system for safety
    while(count < n) {
        int safe = 0;
        for(i = 0; i < n; i++) {
            if(finish[i] == 0) {
                int possible = 1;
                for(j = 0; j < m; j++) {
                    if(need[i][j] > avail[j]) {
                        possible = 0;
                        break;
                    }
                }
                if(possible) {
                    for(j = 0; j < m; j++)
                        avail[j] += alloc[i][j];
                    safeSeq[count++] = i;
                    finish[i] = 1;
                    safe = 1;
                    break;
                }
            }
        }
        if(safe == 0) {
            printf("System is not in safe state.\n");
            return 0;
        }
    }

    printf("System is in safe state.\nSafe sequence: ");
    for(i = 0; i < n; i++)
        printf("%d ", safeSeq[i]);
    printf("\n");

    return 0;
}


input Enter the number of processes: 3
Enter the number of resources: 3
Enter allocation matrix:
1 2 3
2 0 1
3 3 0
Enter max matrix:
4 3 3
3 2 2
4 4 1
Enter available resources:
3 3 2


Deadlock Detection Algorithm
#include <stdio.h>

int main() {
    int i, j, n, m;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resources: ");
    scanf("%d", &m);

    int alloc[n][m], max[n][m], avail[m], need[n][m];
    int finish[n], deadlockDetected = 0;

    printf("Enter allocation matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("Enter max matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("Enter available resources:\n");
    for(i = 0; i < m; i++)
        scanf("%d", &avail[i]);

    for(i = 0; i < n; i++)
        finish[i] = 0;

    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];

    // Check for deadlock
    for(i = 0; i < n; i++) {
        if(finish[i] == 0) {
            int deadlock = 1;
            for(j = 0; j < m; j++) {
                if(need[i][j] <= avail[j]) {
                    deadlock = 0;
                    break;
                }
            }
            if(deadlock) {
                deadlockDetected = 1;
                break;
            }
        }
    }

    if(deadlockDetected) {
        printf("Deadlock detected.\n");
    } else {
        printf("No deadlock detected.\n");
    }

    return 0;
}

input Enter the number of processes: 3
Enter the number of resources: 3
Enter allocation matrix:
1 2 3
2 0 1
3 3 0
Enter max matrix:
4 3 3
3 2 2
4 4 1
Enter available resources:
3 3 2



FIFO Page Replacement Algorithm

#include <stdio.h>

int main() {
    int i, j, n, m, pageFaults = 0, k, flag, pos;
    printf("Enter number of pages: ");
    scanf("%d", &n);
    printf("Enter number of frames: ");
    scanf("%d", &m);
    int pages[n], frames[m], count = 0;

    printf("Enter reference string: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &pages[i]);
    }

    for(i = 0; i < m; i++) {
        frames[i] = -1;
    }

    for(i = 0; i < n; i++) {
        flag = 0;
        for(j = 0; j < m; j++) {
            if(frames[j] == pages[i]) {
                flag = 1;
                break;
            }
        }

        if(flag == 0) {
            frames[count] = pages[i];
            count = (count + 1) % m;
            pageFaults++;
        }
    }

    printf("Page faults: %d\n", pageFaults);
    return 0;
}


Enter number of pages: 7
Enter number of frames: 3
Enter reference string: 7 0 1 2 0 3 0



LRU Page Replacement Algorithm

#include <stdio.h>

int main() {
    int i, j, n, m, pageFaults = 0, flag, pos, least;
    printf("Enter number of pages: ");
    scanf("%d", &n);
    printf("Enter number of frames: ");
    scanf("%d", &m);
    int pages[n], frames[m];

    printf("Enter reference string: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &pages[i]);
    }

    for(i = 0; i < m; i++) {
        frames[i] = -1;
    }

    for(i = 0; i < n; i++) {
        flag = 0;
        for(j = 0; j < m; j++) {
            if(frames[j] == pages[i]) {
                flag = 1;
                break;
            }
        }

        if(flag == 0) {
            least = 0;
            for(j = 1; j < m; j++) {
                if(frames[j] == -1) {
                    least = j;
                    break;
                }
                // Find the least recently used frame
            }
            frames[least] = pages[i];
            pageFaults++;
        }
    }

    printf("Page faults: %d\n", pageFaults);
    return 0;
}

Enter number of pages: 7
Enter number of frames: 3
Enter reference string: 7 0 1 2 0 3 0



Program for Optimal Page Replacement Algorithm

#include <stdio.h>

int findOptimalPage(int pages[], int frames[], int n, int m, int current) {
    int farthest = -1;
    int index = -1;
    for (int i = 0; i < m; i++) {
        int j;
        for (j = current + 1; j < n; j++) {
            if (frames[i] == pages[j]) {
                if (j > farthest) {
                    farthest = j;
                    index = i;
                }
                break;
            }
        }
        if (j == n) return i;
    }
    return index;
}

int main() {
    int n, m, pageFaults = 0;
    printf("Enter number of pages: ");
    scanf("%d", &n);
    printf("Enter number of frames: ");
    scanf("%d", &m);

    int pages[n], frames[m];

    printf("Enter reference string: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &pages[i]);
    }

    for (int i = 0; i < m; i++) {
        frames[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        int flag = 0;
        for (int j = 0; j < m; j++) {
            if (frames[j] == pages[i]) {
                flag = 1;
                break;
            }
        }

        if (flag == 0) {
            int replaceIndex = findOptimalPage(pages, frames, n, m, i);
            frames[replaceIndex] = pages[i];
            pageFaults++;
        }
    }

    printf("Total page faults: %d\n", pageFaults);
    return 0;
}

Enter number of pages: 7
Enter number of frames: 3
Enter reference string: 7 0 1 2 0 3 0

Program to Simulate FCFS Disk Scheduling

#include <stdio.h>

int main() {
    int n, initial, totalSeekTime = 0;
    printf("Enter number of disk requests: ");
    scanf("%d", &n);
    printf("Enter the initial head position: ");
    scanf("%d", &initial);

    int requests[n];
    printf("Enter the disk requests: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    printf("FCFS Disk Scheduling Algorithm\n");
    printf("Request Sequence: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", requests[i]);
        if (i == 0) {
            totalSeekTime += abs(requests[i] - initial);
        } else {
            totalSeekTime += abs(requests[i] - requests[i - 1]);
        }
    }
    printf("\nTotal Seek Time: %d\n", totalSeekTime);
    return 0;
}

Enter number of disk requests: 5
Enter the initial head position: 50
Enter the disk requests: 98 183 37 122 14


Program to Simulate SSTF Disk Scheduling

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, initial, totalSeekTime = 0;
    printf("Enter number of disk requests: ");
    scanf("%d", &n);
    printf("Enter the initial head position: ");
    scanf("%d", &initial);

    int requests[n];
    printf("Enter the disk requests: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    int visited[n];
    for (int i = 0; i < n; i++) {
        visited[i] = 0;
    }

    int current = initial;
    int count = 0;
    while (count < n) {
        int minSeek = 999999, nextRequest = -1;
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                int seek = abs(requests[i] - current);
                if (seek < minSeek) {
                    minSeek = seek;
                    nextRequest = i;
                }
            }
        }
        visited[nextRequest] = 1;
        totalSeekTime += minSeek;
        current = requests[nextRequest];
        count++;
    }

    printf("Total Seek Time: %d\n", totalSeekTime);
    return 0;
}

Enter number of disk requests: 5
Enter the initial head position: 50
Enter the disk requests: 98 183 37 122 14


Program to Simulate SCAN Disk Scheduling

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, initial, totalSeekTime = 0, direction;
    printf("Enter number of disk requests: ");
    scanf("%d", &n);
    printf("Enter the initial head position: ");
    scanf("%d", &initial);
    printf("Enter the direction (1 for right, 0 for left): ");
    scanf("%d", &direction);

    int requests[n];
    printf("Enter the disk requests: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    int left = 0, right = 0;
    for (int i = 0; i < n; i++) {
        if (requests[i] < initial)
            left++;
        else
            right++;
    }

    printf("SCAN Disk Scheduling Algorithm\n");
    if (direction == 1) {
        totalSeekTime += abs(initial - 199);
        for (int i = 0; i < n; i++) {
            totalSeekTime += abs(requests[i] - initial);
        }
    } else {
        totalSeekTime += abs(initial - 0);
        for (int i = 0; i < n; i++) {
            totalSeekTime += abs(requests[i] - initial);
        }
    }
    printf("Total Seek Time: %d\n", totalSeekTime);
    return 0;
}

Enter number of disk requests: 5
Enter the initial head position: 50
Enter the direction (1 for right, 0 for left): 1
Enter the disk requests: 98 183 37 122 14


Program to Simulate C-SCAN Disk Scheduling

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, initial, totalSeekTime = 0;
    printf("Enter number of disk requests: ");
    scanf("%d", &n);
    printf("Enter the initial head position: ");
    scanf("%d", &initial);

    int requests[n];
    printf("Enter the disk requests: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    int left = 0, right = 0;
    for (int i = 0; i < n; i++) {
        if (requests[i] < initial)
            left++;
        else
            right++;
    }

    printf("C-SCAN Disk Scheduling Algorithm\n");
    totalSeekTime += abs(initial - 199); // Move to the farthest right
    for (int i = 0; i < n; i++) {
        totalSeekTime += abs(requests[i] - initial);
    }
    printf("Total Seek Time: %d\n", totalSeekTime);
    return 0;
}

Enter number of disk requests: 5
Enter the initial head position: 50
Enter the disk requests: 98 183 37 122 14


Program for Zombie Process, Orphan Processes, and Array Sum

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void sumEvenOdd(int arr[], int size) {
    pid_t pid = fork();

    if (pid == 0) {
        // Child process - sum odd numbers
        int sumOdd = 0;
        for (int i = 0; i < size; i++) {
            if (arr[i] % 2 != 0) {
                sumOdd += arr[i];
            }
        }
        printf("Child Process: Sum of odd numbers = %d\n", sumOdd);
        exit(0);
    } else {
        // Parent process - sum even numbers
        int sumEven = 0;
        for (int i = 0; i < size; i++) {
            if (arr[i] % 2 == 0) {
                sumEven += arr[i];
            }
        }
        printf("Parent Process: Sum of even numbers = %d\n", sumEven);
        wait(NULL); // Waiting for child to finish
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int size = sizeof(arr) / sizeof(arr[0]);
    sumEvenOdd(arr, size);

    return 0;
}


Shell Script for Student Database Operations

#!/bin/bash

# Function to add a student
add_student() {
    echo "Enter student ID: "
    read id
    echo "Enter student name: "
    read name
    echo "$id $name" >> student_database.txt
    echo "Student added successfully!"
}

# Function to delete a student
delete_student() {
    echo "Enter student ID to delete: "
    read id
    grep -v "^$id" student_database.txt > temp.txt
    mv temp.txt student_database.txt
    echo "Student deleted successfully!"
}

# Function to update student details
update_student() {
    echo "Enter student ID to update: "
    read id
    echo "Enter new name: "
    read name
    sed -i "s/^$id .*/$id $name/" student_database.txt
    echo "Student updated successfully!"
}

# Function to search for a student
search_student() {
    echo "Enter student ID to search: "
    read id
    grep "^$id" student_database.txt
}

echo "Student Database Management"
echo "1. Add student"
echo "2. Delete student"
echo "3. Update student"
echo "4. Search student"
echo "Enter your choice: "
read choice

case $choice in
    1) add_student ;;
    2) delete_student ;;
    3) update_student ;;
    4) search_student ;;
    *) echo "Invalid choice" ;;
esac


1 (Add student)



Program to Read and Copy File Contents Character by Character, Line by Line

#include <stdio.h>

int main() {
    FILE *sourceFile, *destFile;
    char ch;

    sourceFile = fopen("source.txt", "r");
    if (sourceFile == NULL) {
        printf("Source file does not exist.\n");
        return 1;
    }

    destFile = fopen("destination.txt", "w");
    if (destFile == NULL) {
        printf("Unable to create destination file.\n");
        fclose(sourceFile);
        return 1;
    }

    while ((ch = fgetc(sourceFile)) != EOF) {
        fputc(ch, destFile);
    }

    printf("File copied successfully.\n");

    fclose(sourceFile);
    fclose(destFile);

    return 0;
}

Program to Load ALP Program from Input File to Main Memory

#include <stdio.h>
#include <string.h>

#define MEMORY_SIZE 100

int main() {
    FILE *file;
    char memory[MEMORY_SIZE][100];  // Simulating main memory
    char line[100];
    int address = 0;

    file = fopen("input.asm", "r");
    if (file == NULL) {
        printf("Error opening input file.\n");
        return 1;
    }

    while (fgets(line, sizeof(line), file)) {
        if (address >= MEMORY_SIZE) {
            printf("Memory overflow.\n");
            break;
        }
        strcpy(memory[address++], line);
    }

    printf("Program loaded into memory:\n");
    for (int i = 0; i < address; i++) {
        printf("Memory[%d]: %s", i, memory[i]);
    }

    fclose(file);

    return 0;
}

input.asm (ALP code lines like MOV A, B or ADD C, D)


Program to Check Opcode Error in a Given Job and Raise an Interrupt

#include <stdio.h>
#include <string.h>

void checkOpcodeError(char *opcode) {
    // List of valid opcodes (simplified for demonstration)
    char *validOpcodes[] = {"MOV", "ADD", "SUB", "MUL", "DIV"};
    int valid = 0;

    for (int i = 0; i < 5; i++) {
        if (strcmp(opcode, validOpcodes[i]) == 0) {
            valid = 1;
            break;
        }
    }

    if (!valid) {
        printf("Opcode Error: Invalid Opcode - %s\n", opcode);
        printf("Interrupt raised: Opcode Error\n");
    } else {
        printf("Opcode: %s is valid.\n", opcode);
    }
}

int main() {
    char opcode[10];

    printf("Enter the opcode: ");
    scanf("%s", opcode);

    checkOpcodeError(opcode);

    return 0;
}

Enter the opcode: MOV


Program to Check Operand Error in a Given Job and Raise an Interrupt

#include <stdio.h>
#include <string.h>

void checkOperandError(char *operand) {
    // Example of valid operands (simplified)
    char *validOperands[] = {"A", "B", "C", "D"};
    int valid = 0;

    for (int i = 0; i < 4; i++) {
        if (strcmp(operand, validOperands[i]) == 0) {
            valid = 1;
            break;
        }
    }

    if (!valid) {
        printf("Operand Error: Invalid Operand - %s\n", operand);
        printf("Interrupt raised: Operand Error\n");
    } else {
        printf("Operand: %s is valid.\n", operand);
    }
}

int main() {
    char operand[10];

    printf("Enter the operand: ");
    scanf("%s", operand);

    checkOperandError(operand);

    return 0;
}

Enter the operand: A

